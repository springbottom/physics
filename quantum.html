<html>
    <h1 align = "center">Cellular simulation of Schrodinger Wave mechanics</h1>
    <h2 align = "center">in Flat and Curved two dimensional space</h1>
    <canvas align = "center" id = "myc"></canvas>
    <body>
    <script>

        //The work of Joshua Lin; joshua.z.lin@gmail.com
        //Probably for 137B Fall 2017 with Professor A.Charman

        var canvas = document.getElementById("myc");
        var context = canvas.getContext('2d');
        
        var cW = 900;
        var cH = 400;

        canvas.style.width = cW;
        canvas.style.height = cH;
        canvas.width = cW;
        canvas.height = cH;

        canvas.style.marginLeft = "auto";
        canvas.style.marginRight = "auto";
        canvas.parentElement.style.textAlign = "center";

        canvas.style.backgroundColor = "gray";

        var circX = 250;
        var circY = 200;
        var circR = 150;
        

		//I was being dumb the first time
		//Here is the second try; everything prepended with Z; because i have
		//good naming style

		
        function ZdrawFlatBase(){
                //The flat base within which we place our transformed image data
                //An idea is to have a fade effect towards the edges as "space goes to infinity"
                context.beginPath();
                context.arc(circX,circY,circR, 0, 2*Math.PI, false);
                context.lineWidth = 3;
                context.strokeStyle = "black";
                context.stroke();
                context.fillStyle = "white";
                context.fill();
        }

		var Zcells = [];
        var Zpotential = []

		function ZblankCells(){
				for (i = 0; i < 2*circR; i++){
					Zcells.push([]);
					for (j = 0; j < 2*circR; j++){
						if (i == circR){
						if (j == circR){
							Zcells.push([1,0]);
							continue;
						}
						}
						Zcells[Zcells.length - 1].push([0,0]);
						//magnitude, phase
						
					}
				}
		}

		function ZblankPotential(){
				for (i = 0; i < 2*circR; i++){
					Zpotential.push([]);
					for (j = 0; j < 2*circR; j++){
						Zpotential[Zpotential.length - 1].push([0,0]);
						//magnitude, phase
						
					}
				}
		}


		function ZhslToRgb(h, s, l){
			var r, g, b;

			if(s == 0){
				r = g = b = l; // achromatic
			}else{
				var hue2rgb = function hue2rgb(p, q, t){
					if(t < 0) t += 1;
					if(t > 1) t -= 1;
					if(t < 1/6) return p + (q - p) * 6 * t;
					if(t < 1/2) return q;
					if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
					return p;
				}

				var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				var p = 2 * l - q;
				r = hue2rgb(p, q, h + 1/3);
				g = hue2rgb(p, q, h);
				b = hue2rgb(p, q, h - 1/3);
			}

			return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
		}

		function ZpolarToRgb(r, theta){
			//This takes the polar form of the wavefunction and returns the RGB values

			var H = Math.PI + theta;
			var L = (1 - Math.pow(2, -r));
			var S = 1;
			return ZhslToRgb(H,S,L);
		}

		function ZImageData(){
            var img = context.createImageData(2*circR, 2*circR);
            var place = 0;
            var polar = [];
            
            for (i = 0; i < 2*circR; i++){
            for (j = 0; j < 2*circR; j++){
                rgb = ZpolarToRgb(Zcells[i][j][0], Zcells[i][j][1]);
                place = 4*numCells*i*2*circR + 4*numCells*j;
                img[place] = rgb[0];
                img[place + 1] = rgb[1];
                img[place + 2] = rgb[2];
                img[place + 3] = 1;
            }
            }
            return img;
		}

        function Zdraw(){
            context.putImageData(ZImageData(), dx, dy);
        }
		
        var hbar = 1;
        var m = 1;

        function ZinvertMatrix(a,b,c,d){
            return(d/(a*d-b*c), -b/(a*d-b*c), -c/(a*d-b*c), a/(a*d-b*c));
        }

        function ZpolarToCartesian(r,theta){
            return([r*Math.cos(theta), r*Math.sin(theta)]);
        }

		function ZcartesianToPolar(x,y){
				return [Math.pow(Math.pow(x,2)+Math.pow(y,2),0.5), Math.atan2(y,x)];
		}

        var Zscale = 1;

        function ZflatDistance(i,j,k,l){
            //Distance between Zcells[i][j] and Zcells[k][l]
            var polar1 = ZcartesianToPolar((i - circR)*Zscale, (j - circR)*Zscale);
            var polar2 = ZcartesianToPolar((k - circR)*Zscale, (l - circR)*Zscale);

            polar1[0] = Math.tan((Math.PI/2)*polar1[0]/circR);
            polar2[0] = Math.tan((Math.PI/2)*polar2[0]/circR);

            var cart1 = ZpolarToCartesian(polar1[0],polar1[1]);
            var cart2 = ZpolarToCartesian(polar2[0],polar2[1]);

			return (Math.pow(Math.pow(cart1[0]-cart2[0],2)+Math.pow(cart1[1]-cart2[1],2),1/2));
        }

        function ZflatDifference(i,j,k,l){
            //Returns the vector difference
            var polar1 = ZcartesianToPolar((i - circR)*Zscale, (j - circR)*Zscale);
            var polar2 = ZcartesianToPolar((k - circR)*Zscale, (l - circR)*Zscale);

            polar1[0] = Math.tan((Math.PI/2)*polar1[0]/circR);
            polar2[0] = Math.tan((Math.PI/2)*polar2[0]/circR);

            var cart1 = ZpolarToCartesian(polar1[0],polar1[1]);
            var cart2 = ZpolarToCartesian(polar2[0],polar2[1]);

			return ([cart2[0]-cart1[0], cart2[1]-cart1[1]]);

    
        function ZflatLaplacian(i,j){
            //See page 3 in my new book for documentation
            var cart00 = ZpolarToCartesian(Zcells[i][j][0], Zcells[i][j][1]);
            var cart01 = ZpolarToCartesian(Zcells[i][j+1][0], Zcells[i][j+1][1]);
            var cart02 = ZpolarToCartesian(Zcells[i][j+2][0], Zcells[i][j+2][1]);
            var cart10 = ZpolarToCartesian(Zcells[i+1][j][0], Zcells[i+1][j][1]);
            var cart20 = ZpolarToCartesian(Zcells[i+2][j][0], Zcells[i+2][j][1]);
            var du = ZflatDistance(i,j,i+1,j);
            var dv = ZflatDistance(i,j,i,j+1);
            var dfdv00 = [(cart10[0]-cart00[0])/dv,(cart10[1]-cart00[1])/dv];
            var dfdv01 = [(cart20[0]-cart10[0])/dv,(cart20[1]-cart10[1])/dv];
            var dfdv2 = [(dfdu00[0]-dfdu01[0])/dv, (dfdu00[1]-dfdu01[1])/dv];
            var dfdu00 = [(cart01[0]-cart00[0])/du,(cart01[1]-cart00[1])/du];
            var dfdu01 = [(cart02[0]-cart01[0])/du,(cart02[1]-cart01[1])/du];
            var dfdu2 = [(dfdu01[0]-dfdu00[0])/du, (dfdu01[1]-dfdu00[1])/du];
            var duV = ZflatDifference(i,j,i+1,j);
            var dvV = ZflatDifference(i,j,j,j+1);
            var uvinv = ZinvertMatrix(duV[0], duV[1], dvV[0], dvV[1]);
            return (uvinv[0]*dfdu2+uvinv[1]*dfdv2+uvinv[2]*dfdu2+uvinv[3]*dfdv2);
        }
           



		function Zevolve(){


		    














        var numCells = 100; //The number of cells in the simulation for the flat case
        var cells = []
		var resolution = 10; //Something to do with the resolution of the simulation
        //So the basic information stored in a single cell is the wavefunction as a complex number

        for (i = 0; i < numCells; i++){
                cells.push([]);
                for (j = 0; j < numCells; j++){
                        if (i == Math.floor(numCells/2)){
                        if (j == Math.floor(numCells/2)){
                                //Initialise as delta function in the middle of the simulation
                                cells[cells.length-1].push([1,0]);
                                continue;
                        }
                        }
                        cells[cells.length - 1].push([0,0]);
                }
        }
        //So now cells is a numCells * numCells array of complex numbers
                    

        //So the basic idea is that for the flat geometry; we will create an imgData object
        //Where we will store all the pixels
        //Then finally, we will distort this image Data with some transform function
        //Remember to do everything in terms of global variables so parameters can be changed later

		function returnPolar(x,y){
				return [Math.pow(Math.pow(x,2)+Math.pow(y,2),0.5), Math.atan2(y,x)];
		}


        function flatTransform(x,y){
                //Returns the coordinates in the circle for a point (x,y) in cartesian
                var polar = returnPolar(x,y);
				polar[0] = circR*Math.atan(polar[0])/(Math.PI/2);
                return polar;
        }

		function curveToCellular(x,y){
				//takes two coordinates, x and y, relative to the center of the circle
				//THE COORDINATES ARE SCREEN COORDINATES
				//Then we find which cell this corresponds to
				var polar = returnPolar(x,y);
				polar[0] = Math.tan((Math.PI/2)*polar[0]/circR);
				return [Math.floor(polar[0]*Math.cos(polar[1])/resolution) + numCells/2,
						Math.floor(polar[0]*Math.sin(polar[1])/resolution) + numCells/2];
		}

        function drawFlatBase(){
                //The flat base within which we place our transformed image data
                //An idea is to have a fade effect towards the edges as "space goes to infinity"
                context.beginPath();
                context.arc(circX,circY,circR, 0, 2*Math.PI, false);
                context.lineWidth = 3;
                context.strokeStyle = "black";
                context.stroke();
                context.fillStyle = "white";
                context.fill();
        }

		//HSL TO RGB THANKS TO https://gist.github.com/mjackson
		/**
		 * Converts an HSL color value to RGB. Conversion formula
		 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
		 * Assumes h, s, and l are contained in the set [0, 1] and
		 * returns r, g, and b in the set [0, 255].
		 *
		 * @param   {number}  h       The hue
		 * @param   {number}  s       The saturation
		 * @param   {number}  l       The lightness
		 * @return  {Array}           The RGB representation
		 */
		function hslToRgb(h, s, l){
			var r, g, b;

			if(s == 0){
				r = g = b = l; // achromatic
			}else{
				var hue2rgb = function hue2rgb(p, q, t){
					if(t < 0) t += 1;
					if(t > 1) t -= 1;
					if(t < 1/6) return p + (q - p) * 6 * t;
					if(t < 1/2) return q;
					if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
					return p;
				}

				var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				var p = 2 * l - q;
				r = hue2rgb(p, q, h + 1/3);
				g = hue2rgb(p, q, h);
				b = hue2rgb(p, q, h - 1/3);
			}

			return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
		}

		function polarToRgb(r, theta){
			//This takes the polar form of the wavefunction and returns the RGB values

			var H = Math.PI + theta;
			var L = (1 - Math.pow(2, -r));
			var S = 1;
			return hslToRgb(H,S,L);
		}
			

		function rawImageData(){

			var img = context.createImageData(numCells, numCells);
			var place = 0;
			var polar = [];
			var rgb = [];
			
			for (i = 0; i < numCells; i++){
			for (j = 0; j < numCells; j++){
				place = 4*numCells*i + 4*numCells*j;
				polar = returnPolar(cells[i][j][0], cells[i][j][1]);
				rgb = polarToRgb(polar[0][1]);
				img[place] = rgb[0];
				img[place + 1] = rgb[1];
				img[place + 2] = rgb[2];
				img[place + 3] = 1;
			}
			}
			return img;
		}

        function drawCells(){
                //Now the idea is that polar angle will correspond to color
                //and the radius to saturation. More precisely, we use the first method described in this
				//https://en.wikipedia.org/wiki/Color_wheel_graphs_of_complex_functions wikipedia article

				img = rawImageData();
				var imgDis = context.createImageData(2*circR, 2*circR);
				var place = 0;
				var cellCoord = [];

				for (i = 0; i < 2*circR; i++){
				for (j = 0; j < 2*circR; j++){
					if (Math.pow(i - circR, 2) + Math.pow(j - circR, 2) >= Math.pow(circR,2)){
						continue;
						//the pixel is outside of the rendered circle, so we might as well skip
					}
				}
				}			
					
				
        }




    </script>
    </body>
</html>
